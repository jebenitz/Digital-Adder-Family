

\documentclass[12 pt]{article}
\usepackage[a4paper, top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{physics}
\usepackage{gensymb}
\usepackage{float}         
\usepackage{booktabs}

\usepackage{tabularx}
\usepackage{graphicx} 
\usepackage{caption}  


\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{verilog}{
	language=Verilog,
	basicstyle=\ttfamily\footnotesize,
	commentstyle=\color{codegreen},
	keywordstyle=\color{blue},
	numberstyle=\tiny\color{codegray},
	numbers=left,
	numbersep=5pt,
	frame=single,
	breaklines=true,
	captionpos=b
	showspaces=false,       
	showstringspaces=false, 
	showtabs=false      
}

\newcommand{\myabstract}[1]{
	\noindent
	\fontfamily{ptm}\selectfont
	\fontseries{b}\selectfont
	\textbf{\textit{ Abstract—}} #1
	\normalfont
}

\date{11/2025}
\title{\textbf{\LARGE Digital Adder Family: From Basic Gates to 64-bit Carry-Lookahead} \vspace{6cm}}
\author{ Julia E. Benítez }  

\begin{document}
		\newgeometry{top=10.5cm, bottom=2cm, left=2cm, right=2cm}
	\maketitle
	% ---
	\newgeometry{top=2cm, bottom=2cm, left=2cm, right=2cm}
	
	\tableofcontents
	% ---
	\newgeometry{top=2cm, bottom=2cm, left=2cm, right=2cm}
	
	

	
	\section{Introduction}
	
	This work explores the implementation of the most fundamental unit in combinational logic design: the adder, tracing its journey from basic Boolean equations through various architectural implementations at both gate and transistor levels. 
	
	Time efficiency stands as a critical factor in digital design, forming the central focus of this investigation, particularly how Boolean logic translates into real circuit behavior through CMOS technology. What began as a simple Verilog learning exercise evolved through multiple stages into a exploration of CMOS physics analyzed in LTspice, revealing the significant gap between digital abstraction and physical reality.
	
	The path from Verilog simulation to CMOS implementation uncovered fundamental questions: How do idealized gate delays compare to actual propagation times? What optimization benefits survive the transition from Boolean algebra to physical transistors? And how do parasitic effects impact circuit behavior in ways invisible to digital simulation?
	
	This project addresses these questions through development of  adder architectures, experimental characterization of CMOS gates and comparative analysis of timing performance across different levels of abstraction.
	
	% ---
	
	
	
	\section{Theoretical Background}
	\subsection{Binary Addition Fundamentals}

	 
	 A bit, the fundamental unit of binary data, is a boolean value represented as either 0 or 1. The addition of two single bits follows four basic rules:
	 
	 \begin{center}
	  0 + 0 = 0 \\
	 0 + 1 = 1 \\
	 1 + 0 = 1\\
	 1 + 1 = 0\\ 
	 \end{center}
	 
	 A particular case occurs when  both bits are 1 , it produces a sum of 0 and generates a \textbf{carry-out} of 1. This carry must be propagated to the next significant bit position.
	 
	 Figure~\ref{fig:binary_addition_example} demonstrates this process by adding the two-bit numbers $A = 01$ and $B = 11$ using the traditional columnar method:
	 
	 \begin{figure}[h]
	 	\centering
	 	\begin{tabular}{r@{\,}c@{\,}c@{\,}c@{\,}l}
	 		&  Carry& & 1 & 1 \\
	 		& & $A$ & 0 & 1 \\
	 		& + & $B$ & 1 & 1 \\
	 		\cline{2-5}
	 		&  Sum & & 10 & 0 \\
	 	\end{tabular}
	 	\caption{Binary addition example showing carry propagation}
	 	\label{fig:binary_addition_example}
	 \end{figure}
	 
	 The addition proceeds from right to left (Least Significant Bit to Most Significant Bit) for the
	bit 0 (LSB): $1 + 1 = 0$ with carry-out of 1, then for
	 	bit 1: $0 + 1 + 1$ (carry-in) $= 0$ with carry-out of 1, and for bit 2: $0 + 0 + 1$ (carry-in) $= 1$

	 
	 Note that adding two 2-bit numbers produces a 3-bit result due to the final carry-out. This demonstrates that the result's width can exceed that of the operands. (This concept will later be discussed as overflow).
	 
	 As operand size increases, the sequential propagation of carries from LSB to MSB becomes the dominant factor in adder performance. This \textbf{carry-propagation delay} is a critical timing constraint in arithmetic logic unit design and motivates various adder optimization techniques. \\
	 
	
	\subsection{Full Adder Design}
	
	\subsubsection{Half-Adder}
	
	The Half-Adder is a combinational logic circuit that implements the addition of two single bits. Based on the fundamental rules of binary addition, its behavior is defined by the following truth table (Figure \ref{fig:half_adder_truth_table}):
	
	\begin{figure}[h]
		\centering
		\begin{tabular}{cc|c|c}
			\hline
			\textbf{A} & \textbf{B} & \textbf{Sum (S)} & \textbf{Carry (C)} \\
			\hline
			0 & 0 & 0 & 0 \\
			0 & 1 & 1 & 0 \\
			1 & 0 & 1 & 0 \\
			1 & 1 & 0 & 1 \\
			\hline
		\end{tabular}
		\caption{Half-Adder truth table}
		\label{fig:half_adder_truth_table} 
	\end{figure}
	
	The Boolean equations for the Sum (S) and Carry (C) outputs are derived using a Karnaugh Map (K-Map). The notation used for Boolean operations is as follows: the $+$ symbol represents the OR operation, $\cdot$ (or its omission) represents the AND operation, and $\oplus$ represents the XOR operation.
	
	\begin{align*}
		S &= A'B + AB' = A \oplus B \\
		C &= AB
	\end{align*}
	
	These equations can be implemented using logic gates. Figure~\ref{fig:2-1HA} shows the direct implementation using fundamental gates (AND, OR, NOT), while Figure~\ref{fig:2-1HAXOR} shows the more common and efficient implementation that utilizes an XOR gate for the sum output.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{2-1HA.png}
			\caption{Half-Adder implementation with basic gates}
			\label{fig:2-1HA}
		\end{minipage}
		\hfill
		\begin{minipage}[b]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{2-2HAXOR.png}
			\caption{Half-Adder implementation with an XOR gate}
			\label{fig:2-1HAXOR}
		\end{minipage}
	\end{figure}
	
	\subsubsection{Full Adder}
	
	The Half-Adder has a significant limitation: it cannot account for an incoming carry from a previous addition. To create an adder capable of chaining together for multi-bit operations, a third input called the \textbf{carry-in} ($C_{in}$) is introduced. This circuit is known as a \textbf{Full Adder}(FA). \\
	
	The Full Adder adds three single-bit inputs—A, B, and $C_{in}$—and produces a Sum (S) and a \textbf{carry-out} ($C_{out}$). Its complete functionality is described by the following truth table:
	
	\begin{figure}[h]
		\centering
		\begin{tabular}{ccc|c|c}
			\hline
			\textbf{A} & \textbf{B} & \textbf{$C_{in}$} & \textbf{Sum (S)} & \textbf{$C_{out}$} \\
			\hline
			0 & 0 & 0 & 0 & 0\\
			0 & 0 & 1 & 1 & 0\\
			0 & 1 & 0 & 1 & 0\\
			0 & 1 & 1 & 0 & 1\\
			1 & 0 & 0 & 1 & 0\\
			1 & 0 & 1 & 0 & 1\\
			1 & 1 & 0 & 0 & 1\\
			1 & 1 & 1 & 1 & 1\\
			\hline
		\end{tabular}
		\caption{Full-Adder truth table}
		\label{fig:full_adder_truth_table} 
	\end{figure}
	
	The Boolean equations for the Sum and Carry-out are derived from this table. For the Sum output:
	
	\begin{align*}
		S &= A'B'C_{in} + A'BC_{in}' + AB'C_{in}' + ABC_{in} \\
		S &= C_{in} \oplus (A \oplus B)
	\end{align*}
	
	The Carry-out equation can also be minimized.
	\begin{align*}
		C_{out} &= BC_{in} + AC_{in} + AB 
	\end{align*}
	
	 While it can be expressed in a minimal sum-of-products form, it is often more efficient to implement it using the same XOR term shared with the Sum logic, reducing overall circuit complexity:
	\begin{align*}
		C_{out} &= AB + A'BC_{in} + AB'C_{in} = AB + C_{in}(A'B+AB') \\
		C_{out} &= AB + C_{in}(A \oplus B)
	\end{align*}
	
	
	The key insight in this implementation is the shared term $(A \oplus B)$ between both the Sum and Carry-out equations. It reduces the number of logic gates required. Figure~\ref{fig:2-3FA} shows the gate-level implementation of the Full Adder based on these optimized equations.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{0.8\textwidth}
			\centering
			\includegraphics[width=\textwidth]{2-3FA.png}
			\caption{Full-Adder implementation using shared XOR logic}
			\label{fig:2-3FA}
		\end{minipage}
	\end{figure}
	
\subsection{Ripple-Carry Adder}

The Full-Adder can be extended to perform multi-bit addition through an iterative approach. A straightforward design that mimics traditional manual addition chains the carry-out of one Full-Adder to the carry-in of the next. In this configuration, the carry signal propagates sequentially through the entire chain. This design is known as a Ripple-Carry Adder (RCA), as illustrated in Figure~\ref{fig:2-4RCA}.

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.8\textwidth}
		\centering
		\includegraphics[width=\textwidth]{2-4RCA.png}
		\caption{N-bit Ripple Carry Adder architecture}
		\label{fig:2-4RCA}
	\end{minipage}
\end{figure}

The operands are distributed across the single-bit inputs of each Full-Adder module, beginning with the Least Significant Bit (LSB) at positions $A_0$, $B_0$. The individual sum outputs are concatenated to form the complete output word $S$, with the final carry-out from the last adder included to create an N+1-bit result (assuming unsigned operands).

Propagation delay is a critical consideration in this design. Since each sum output depends on its carry-in, which must propagate through the entire preceding chain, the worst-case delay occurs when a carry ripples through all stages. Examining the Full-Adder implementation in Figure~\ref{fig:2-3FA}, the critical path for carry propagation passes through approximately three gate delays per stage. This results in an overall time complexity of $O(N)$, meaning the addition time increases linearly with operand size.

While the RCA provides a simple solution for small operand widths (where propagation delay remains acceptable), its linear timing characteristic becomes prohibitive for larger bit widths. This limitation motivates the development of alternative adder architectures that employ parallel computation to overcome the carry propagation bottleneck.
	
\subsection{Carry-Lookahead Adder (CLA)}
\subsubsection{Single-Level CLA}

To overcome the linear propagation delay of the Ripple-Carry Adder, parallel computation introduces a new architecture: the Carry-Lookahead Adder (CLA). The CLA employs a separate module that computes all carry signals simultaneously using two auxiliary signals derived from each Full-Adder stage.

Building upon the Full-Adder carry equation, we express $C_{out}$ in terms of two new variables: $P$ (Propagate) and $G$ (Generate).

\begin{align*}
	C_{out} &= AB + C_{in}(A \oplus B) \\
	C_{out} &= G + C_{in}P
\end{align*}

where $G = AB$ represents a generated carry, and $P = A \oplus B$ represents a propagated carry. For multiple stages, the general form for the carry at position $i+1$ is:

\begin{equation}
	C_{i+1} = G_i + P_iC_i
	\label{eq:CLAexpression}
\end{equation}

By recursively applying Equation~\ref{eq:CLAexpression}, we can express all carries in terms of the independent Generate ($G_i$) and Propagate ($P_i$) signals, along with the initial carry-in $C_0$:

\begin{align*}
	C_1 &= G_0 + P_0C_0 \\
	C_2 &= G_1 + P_1C_1 = G_1 + P_1G_0 + P_1P_0C_0 \\
	C_3 &= G_2 + P_2C_2 = G_2 + P_2G_1 + P_2P_1G_0 + P_2P_1P_0C_0 \\
	C_4 &= G_3 + P_3C_3 = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 + P_3P_2P_1P_0C_0
\end{align*}

The complexity of the carry logic expands with each subsequent stage, both in the number of terms and the fan-in requirements of the gates. This growth imposes a practical limit on the size of a single-level carry generator. Figure~\ref{fig:4bitCLA} shows a 4-bit CLA implementation where four Full-Adders are fed with pre-computed carry signals, with $C_4$ serving as the final carry-out.

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.9\textwidth}
		\centering
		\includegraphics[width=\textwidth]{2-54bitCLA.png}
		\caption{4-bit Carry-Lookahead Adder architecture}
		\label{fig:4bitCLA}
	\end{minipage}
\end{figure}

While the critical path per stage remains approximately 3 gate delays, the key advantage is that all carries are computed in parallel. This means the propagation delay for $S_1$ through $S_3$ is nearly identical, resulting in constant time complexity $O(1)$ for the carry computation within the block. The CLA achieves significant speed improvement at the cost of increased circuit complexity—as more bits are added, the carry generation logic requires more gates with higher fan-in. 

Finally total Sum is calculated using:
\[ S_i = P_i \oplus C_i \]

To scale this approach efficiently, a hierarchical architecture using group propagate and generate signals becomes necessary.
	 
\subsubsection{64-bit Hierarchical Architecture}

Constructing a 64-bit Carry-Lookahead Adder requires a hierarchical approach to manage circuit complexity. While various configurations are possible—such as chaining four 16-bit adders with mixed lookahead and ripple-carry propagation, this project employs a consistent three-level hierarchy using 4-bit CLA modules and 4-signal carry generators. This design enables module reuse while minimizing propagation delay.

The hierarchical approach introduces group propagate ($P_g$) and generate ($G_g$) signals for 4-bit blocks:
\begin{align*}		
	P_g &= P_3 \cdot P_2 \cdot P_1 \cdot P_0 \\
	G_g &= G_3 + P_3 \cdot G_2 + P_3 \cdot P_2 \cdot G_1 + P_3 \cdot P_2 \cdot P_1 \cdot G_0
\end{align*}

This necessitates a modification to the basic 4-bit CLA design (Figure~\ref{fig:4bitCLA}): the explicit $C_4$ output is omitted since it can be derived as $C_4 = G_g + P_g \cdot C_0$.

The same carry generation principles scale to higher levels. Figure~\ref{fig:16bitCLA} shows how four 4-bit CLAs combine with a second-level carry generator to form a 16-bit CLA, using group signals as inputs. Similarly, Figure~\ref{fig:64bitCLA} demonstrates the complete 64-bit architecture, where four 16-bit CLAs feed into a third-level carry generator.

\newpage 
\newgeometry{top=1cm, bottom=2cm, left=1cm, right=1cm}

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{2-6Full64CLA.png}
		\caption{Complete 64-bit hierarchical CLA architecture}
		\label{fig:64bitCLA}
	\end{minipage}
	
	\vspace{1cm} % <-- adjust this space as you like
	
	\begin{minipage}[b]{0.7\textwidth}
		\includegraphics[width=\textwidth]{2-6CLA64-16ex.png}
		\caption{Internal structure of a 16-bit CLA block (detailed view)}
		\label{fig:16bitCLA}
	\end{minipage}
\end{figure}


\newpage
\restoregeometry

The complete implementation comprises: 64 Full-Adder modules, 16 first-level carry generators (4-bit), 4 second-level carry generators (16-bit), 1 third-level carry generator (64-bit).

Signal widths follow the hierarchy: $G_{level2}$, $P_{level2}$, and $C_{level2}$ are 16-bit buses shared across 16-bit modules, while level-3 signals are 4-bit wide. This will be further justified during the Verilog implementation.

\subsubsection{Time Analysis} 

Assuming a delay of one time unit per logic gate, the carry propagation within each 4-bit CLA (Level-1) requires approximately three time units: one unit for ($P_i$) and ($G_i$), and two additional units for computing ($G_g$). The corresponding sum output requires one extra gate level, yielding a total of four time units for local sum computation.

For higher hierarchy levels, each 16-bit and 64-bit carry generator (Levels 2--3) adds about four time units due to additional group-propagate and group-generate logic. Then, the global carry output emerges after approximately ten time units, while the complete sum becomes valid after twelve time units.

This hierarchical delay has logarithmic scaling with operand width, following roughly $4 \cdot \log_{4} N$ time units. For a 64-bit implementation, this yields 12 units compared to the 192 time units of a 64-bit Ripple-Carry Adder (assuming three gate delays per full adder $3 \cdot 64 $). CLA is 16$\times$ faster than a RCA.

\subsection{CMOS Implementation}
\subsubsection{CMOS Digital Logic Circuits Basics}
		
CMOS technology forms the foundation of modern digital design, using complementary pairs of PMOS and NMOS transistors to implement logic gates. In digital applications, MOS transistors operate primarily in the cutoff region (boolean 0) and triode region (boolean 1 at $V_{DD}$), enabling efficient switching behavior.

The fundamental structure of CMOS gates consists of two complementary networks: the Pull-Up Network (PUN) comprising PMOS transistors, and the Pull-Down Network (PDN) comprising NMOS transistors. The inverter, as the basic building block, demonstrates this complementary principle: when input is low, the PMOS conducts, pulling output to $V_{DD}$; when input is high, the NMOS conducts, pulling output to ground.

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.37\textwidth}
		\includegraphics[width=\textwidth]{2-6Inverter.png}
		\caption{Basic inverter using PMOS and NMOS transistors}
		\label{fig:Inverter}
	\end{minipage}
	\hspace{0.5cm}
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{2-6PDNPUN.png}
		\caption{General structure of a CMOS logic-gate circuit}
		\label{fig:PUPDnetworks}
	\end{minipage}
\end{figure}

For complex gates, the PUN produces strong logic 1 states when the Boolean function $Y(In_1, In_2,...,In_n)$ is true, while the PDN produces strong logic 0 states when the function is false. Basic operations map directly to transistor arrangements: OR functions use parallel paths, while AND functions use series connections. Most CMOS gates exhibit dual topology where parallel PMOS paths correspond to series NMOS paths and vice versa.	

	\subsubsection{CMOS Gate design} 
	OR gate CMOS logic circuit design can be derived from the equation:
	\[ Y = A + B \]
	
	To obtain the PUN expression, as previously stated Y must be true, but for this to happen A and B must be off. Therefore, instead of working with the OR gate directly, analysis is more easily done with the NOR gate:
	\[ Y = (A+B)' \]
	
	Using De Morgan's laws:
	\[ Y = A'B' \]  
	and equivalently for PDN:
	\[ Y' = ((A+B)')' = A + B \]
	
	So we obtain a series arrangement for PUN and a parallel arrangement for PDN. Note that this network will produce NOR output; to obtain OR, it's necessary to use an additional inverter at the output.
	
	Similarly for AND gate, NAND gate is built and then output is inverted to obtain AND. For PUN and PDN NAND gate:
	\[ Z = (AB)' = A' + B' \]
	\[ Z' = ((AB)')' = AB \]
	
	Therefore the PUN will be a parallel arrangement while PDN will be a series arrangement. This idea can be expanded to create gates with more inputs; in a NAND gate, more series transistors can be added in the PDN, one per additional input (and equally parallel transistors in PUN).
	
	Examining the XOR gate equation, note that outputs cannot be expressed as direct dual networks but some must be inverted for both PUN and PDN:
	\[ Z_2 = A'B + AB' \]
	
	\[ Z_2' = (A'B + AB')' = (A'B)'(AB')' = (A+B')(A'+B) = AB + A'B' \]
	
	XOR will have 8 transistors considering that B' and A' are already given; if not, the circuit will have 4 additional transistors for A and B signal inverters. Note that XOR gate is not a dual network.
	
	\subsubsection{Full Adder CMOS Implementation}
	
	According to the full adder logic diagram and current CMOS gate design methodology, it would take 42 MOS transistors to build a gate-level implementation. However, new pairs of equations for Sum and Carry out can be derived for optimization.
	
	According to the Carry out minimized equation:
	\[ C_{out} = BC_{in} + AC_{in} + AB = AB + C_{in}(B + A) \]
	
	Similarly to AND/OR gates, operating with the inverse function is convenient. For the PUN:
	\[ NC_{out} = C_{out}' = (AB + C_{in}(B + A))' = (AB)'(C_{in}(B+A))' = (A' + B')(C_{in}' + (A+B)') \]
	
	\[ NC_{out} = (A' + B')(C_{in}' + A'B') \]
	
	and for the PDN, $NC_{out}'$ is the original function:
	\[ NC_{out}' = AB + C_{in}(B + A) \]
	
	This reduces the total necessary MOS transistors from 36 (using  gates) to only 12.
	
	For the Sum equation, the terms can be factorized in a clever way:
	\[ S = A'B'C_{in} + A'BC_{in}' + AB'C_{in}' + ABC_{in} \]
	
	\[ S = ABC_{in} + (A + B + C_{in})(A'C_{in}' + B'C_{in}' + A'B') = ABC_{in} + (A + B + C_{in})(A' + B')(C_{in}' + A'B') \]
	
	\[ S = ABC_{in} + (A + B + C_{in})NC_{out} \]
	
	Using this expression, PUN and PDN equations are built as was done for $C_{out}$:
	
	\[ NS = S' = (ABC_{in} + (A + B + C_{in})NC_{out})' = (A'B'C_{in}'+ NC_{out}')(A' + B' + C_{in}') \]
	
	\[ NS' = ABC_{in} + (A + B + C_{in})NC_{out} \]
	
	Notice that $NC_{out}$ is reused. Sum uses 16 MOS transistors, making the total gate count 28. This design is known as Adder-28T.
	
	All circuit models can be found in Section 3.3.
	 
	\subsubsection{Propagation Delay Analysis}
	
	Feeding an inverter input with an ideal pulse results in a rounded output pulse, indicating finite transition times between high and low states. These delay times result from various capacitances in the circuit (MOSFET, wiring, and input capacitances). Two asymmetric delay times are defined for analysis as shown in Figure \ref{fig:Delay}, where the "switching point" occurs at $V_{DD}/2$.
	
	The inverter propagation delay is defined as:
	\[ t_p = \frac{1}{2}(t_{PHL} + t_{PLH}) \]
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{1\textwidth}
			\includegraphics[width=\textwidth]{2-6delay.png}
			\caption{Input and output of inverter, delays are indicated}
			\label{fig:Delay}
		\end{minipage}
	\end{figure}
	
	Using the following equations, both delays can be found as functions of MOSFET channel width and length:
	
	\[ t_{PHL} = 0.69 R_N C \quad \text{with} \quad R_N = \frac{12.5}{(W/L)_n}\ \text{k}\Omega \]
	
	\[ t_{PLH} = 0.69 R_P C \quad \text{with} \quad R_P = \frac{30}{(W/L)_p}\ \text{k}\Omega \]
	
	where $C$ is the load capacitance.
	
		
	\section{Design and Implementation}
	\subsection{RTL Design in Verilog}
	\subsubsection{Full Adder Implementation}
	
	The Full Adder module implements the single-bit addition logic derived in Section 2.2.2, with three input bits (x, y, z) and two outputs (sum s, carry c). The design  reuses intermediate XOR operation to minimize gate count.
	
\begin{lstlisting}[style=verilog, caption={Single-bit Full Adder Implementation}, label=code:full_adder, ]
/**
* Single-bit full adder module 
*
* Outputs are produced according to the following boolean equations:
* s = x ^ y ^ z
* c = x & y | z & (x ^ y)
*/
	
module full_adder (
input x, y, z,
output s, c
);
	
	wire x_xor_y; 
	assign x_xor_y = x ^ y;  // Intermediate signal: XOR of x and y
	
	assign s = z ^ x_xor_y; 
	assign c = (x & y) | (z & x_xor_y); 
	
endmodule
\end{lstlisting}
	
		This implementation directly corresponds to the  equations presented in Section 2.2.2. Verilog assignments map directly to the logic gate arrangement shown in Figure~\ref{fig:2-3FA}, with approximately 3-gate propagation delay for critical paths.

	
	Module serves as the fundamental building block for all subsequent adder implementations in the hierarchy.
	
\subsubsection{Ripple-Carry Adder Implementation}

A parameterized N-bit Ripple-Carry Adder is implemented by chaining N full adder modules, following the architecture shown in Figure~\ref{fig:2-4RCA}. The design uses Full Adder module from Section 3.1.1.

\begin{lstlisting}[style=verilog, caption={N-bit Ripple Carry Adder Implementation}, label=code:N-bitRCA]
	/**
	* N-bit Ripple Carry Adder (RCA)
	* 
	* @param N     Bit width of the adder (default: 8)
	*/
	
	`include "full_adder.v"  // Include the full adder module
	
	module ripple_carry_adder 
	#(parameter N = 8)    // Configurable bit width
	(
	input  [N-1:0] N1,    // First N-bit operand
	input  [N-1:0] N2,    // Second N-bit operand  
	input          cin,   // Carry-in input
	output [N-1:0] St,    // N-bit sum output
	output         cout   // Carry-out output
	);
	
	// Internal carry chain: carry[i] is the carry-out from bit position i
	wire [N:0] carry;  // N+1 bits to include cin and cout
	
	assign carry[0] = cin;  // First carry-in
	
	// Generate chain of N full adders
	genvar i;
	generate
	for (i = 0; i < N; i = i + 1) begin : FA_CHAIN
	full_adder fa (
	.x(N1[i]),
	.y(N2[i]),
	.z(carry[i]),   // Carry from previous stage
	.s(St[i]),
	.c(carry[i+1])  // Carry to next stage
	);
	end
	endgenerate
	
	assign cout = carry[N];  // Final carry-out
	
	endmodule
\end{lstlisting}

The carry chaining is accomplished using a \texttt{generate} block and an internal N+1-bit \texttt{carry} bus. This implementation exhibits a worst-case propagation delay of approximately $3N$ gate delays, resulting in $O(N)$ time complexity. While area-efficient and simple to implement, this linear scaling makes the RCA suitable only for small values of N or applications where speed is not critical.

\subsubsection{4-bit CLA Block Design}

This module implements the 4-bit Carry Lookahead Adder following the theoretical design established in Section 2.4.1. Unlike the Ripple-Carry approach, it computes all carry signals in parallel using propagate and generate logic, without explicitly instantiating Full Adder modules.

\begin{lstlisting}[style=verilog, caption={4-bit Carry Lookahead Adder Implementation}, label=code:4bitCLA]
	/**
	* 4-bit Carry Lookahead Adder (CLA)
	* 
	* Implements parallel carry computation using group P/G signals
	* for hierarchical expansion in larger CLA architectures
	*/
	
	module carry_lookahead_4bit (
	input  [3:0] A,        // 4-bit operand A
	input  [3:0] B,        // 4-bit operand B
	input        cin,      // Carry input
	output [3:0] S,        // 4-bit sum output
	output       Pg,       // Group Propagate (for hierarchical expansion)
	output       Gg        // Group Generate (for hierarchical expansion)
	);
	
	wire [3:0] P, G;       // Individual bit propagate/generate signals
	wire [3:0] C;          // Internal carry chain
	
	// Bit-level propagate and generate
	assign P = A ^ B;      // Propagate: A XOR B
	assign G = A & B;      // Generate: A AND B
	
	assign C[0] = cin;     // External carry-in
	
	// Parallel carry computation
	genvar i;
	generate 
	for (i = 1; i < 4; i = i + 1) begin : carry_lookahead_chain
	// Carry equation: C[i] = G[i-1] | (P[i-1] & C[i-1])
	assign C[i] = G[i-1] | (P[i-1] & C[i-1]);
	end
	endgenerate
	
	// Sum computation
	assign S = P ^ C;
	
	// Group signals for hierarchical expansion
	assign Pg = &P;  // P[3] & P[2] & P[1] & P[0] - all bits propagate
	assign Gg = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) | 
	(P[3] & P[2] & P[1] & G[0]);  // Group generate
	
	endmodule
\end{lstlisting}

The design employs three internal buses: individual propagate (\texttt{P}) and generate (\texttt{G}) signals, and the computed carry chain (\texttt{C}). An architectural decision replaces the explicit carry-out with group propagate (\texttt{Pg}) and generate (\texttt{Gg}) signals, enabling efficient hierarchical composition in larger CLA structures. This modification aligns with the hierarchical equations defined in Section 2.4.2 and facilitates the 64-bit CLA implementation.
	
	\subsubsection{64-bit CLA Integration}
	
	This module performs 64-bit addition by instantiating sixteen 4-bit CLA modules in a hierarchical structure. The first level is constituted by 16-bit blocks, each containing four 4-bit CLA modules with a carry generator that processes group propagate (Pg) and generate (Gg) signals.The second level combines four 16-bit blocks using the same auxiliary module to form the complete 64-bit CLA, following diagram presented in figure \ref{code:64bitCLA}.

	
	
		
/*
*\begin{lstlisting}[style=verilog, caption={64-bit Full Carry Lookahead Adder Implementation}, label=code:64bitCLA ]
* 64-bit Carry Lookahead Adder (CLA)
*
*NOTE: This adder treats operands as UNSIGNED integers.
*/

`include "Adder4bitsCLA.v"

module add64CLA #(parameter N = 64)(
input  [N-1:0] A, B,  
input  carry_in,
output [N-1:0] S, 
output carry_out
);

localparam BLOCKS_16B = N / 16;
localparam BLOCKS_4B  = N / 4;

// 4-bit level signals (level 3)
wire [BLOCKS_4B-1:0] prop_4b_blocks, gen_4b_blocks;
wire [BLOCKS_4B-1:0] carry_4b_blocks;

// 16-bit level signals (level 2)
wire [BLOCKS_16B-1:0] prop_16b_blocks, gen_16b_blocks, carry_16b_blocks;

// Global level (64 bits) signals
wire prop_global_64b, gen_global_64b;

genvar i, j;
generate 
for (j = 0; j < BLOCKS_16B; j = j + 1) begin : group16
// Instantiate four 4-bit CLAs for each 16-bit block
for (i = 0; i < 4; i = i + 1) begin : group4
carry_lookahead_4bit add4_inst (
.A   (A[((16*j)+(i+1)*4) -1 : (16*j)+(i*4)]),
.B   (B[((16*j)+(i+1)*4) -1 : (16*j)+(i*4)]),
.cin (carry_4b_blocks[(4*j)+i]),
.S   (S[((16*j)+(i+1)*4) -1 : (16*j)+(i*4)]),
.Pg  (prop_4b_blocks[(4*j)+i]),
.Gg  (gen_4b_blocks[(4*j)+i])
);
end

// Second level Carry Lookahead (16 bits)
// Generates carry signals for the 4-bit blocks within this 16-bit group
CLA4 cla16_inst (
.P   (prop_4b_blocks[(j+1)*4 - 1 : j*4]),
.G   (gen_4b_blocks[(j+1)*4 - 1 : j*4]), 
.cin (carry_16b_blocks[j]),
.C   (carry_4b_blocks[(j+1)*4 - 1 : j*4]),
.Pg  (prop_16b_blocks[j]),
.Gg  (gen_16b_blocks[j])
);
end
endgenerate 

// Third level Carry Lookahead (64 bits)
// Generates carry signals for the 16-bit blocks
CLA4 cla64_inst (
.P   (prop_16b_blocks),
.G   (gen_16b_blocks), 
.cin (carry_in),
.C   (carry_16b_blocks),
.Pg  (prop_global_64b),
.Gg  (gen_global_64b)
);

// Final global carry output
assign carry_out = gen_global_64b | (prop_global_64b & carry_in);

endmodule

// Auxiliary carry generator module for 4 CLA modules
// Computes carry signals using group propagate and generate signals
module CLA4 (
input  [3:0] P, G,    
input  cin,           
output [3:0] C,       
output Pg, Gg         
);

assign C[0] = cin;

// Generate carry signals for positions 1-3
genvar i;
generate 
for (i = 1; i < 4; i = i + 1) begin : carries_chain
assign C[i] = G[i-1] | (P[i-1] & C[i-1]);
end
endgenerate 

// Group Propagate
assign Pg = &P;  // P[3] & P[2] & P[1] & P[0]

// Group Generate
assign Gg = G[3] 
| (P[3] & G[2]) 
| (P[3] & P[2] & G[1]) 
| (P[3] & P[2] & P[1] & G[0]); 
endmodule
					
	\end{lstlisting}
	
	The auxiliary \texttt{CLA4} module implements the same carry generation logic as the 4-bit CLA but operates on group signals rather than individual bits. The global carry-out is computed from the third-level group signals using the fundamental carry equation $C_{out} = G + P \cdot C_{in}$. \\
	
	A key implementation detail involves the optimized bus distribution across hierarchy levels. The nested \texttt{generate} blocks partition the 64-bit operands into appropriate slices: input operands are split into 4-bit chunks (\texttt{A[((16*j)+(i+1)*4)-1 : (16*j)+(i*4)]}), while propagate/generate signals are grouped into 4-bit buses (\texttt{prop\_4b\_blocks[(j+1)*4-1 : j*4]}) for second-level carry computation. This maintains consistent 4-bit granularity throughout the hierarchy while enabling efficient 16-bit and 64-bit aggregation.
	
\subsection{Verification Methodology}
\subsubsection{Testbench Structure}

All testbenches follow a consistent structure: registers drive module inputs, wires capture outputs, and waveform files enable visual analysis via GTKWave. 

Input operands A and B are systematically varied to verify that output S and carry-out signals adhere to the binary addition rules established in Section 2.1. 

For the Full Adder module, which has only 8 possible input combinations, visual inspection of waveforms suffices for verification. For larger modules where exhaustive visual verification becomes impractical, a comparative approach leverages Verilog's native `+` operator. This built-in operator handles multi-bit addition in a single line, automatically managing carry propagation and providing a reference result.

Since the sum of A + B may exceed the bit width of S due to carry-out, proper comparison requires concatenating S and Cout into an (N+1)-bit vector. This approach correctly handles unsigned overflow conditions.

All simulations use a timescale of 1ns/1ps. Although Verilog computes operations instantaneously without modeling propagation delay, this timescale allows clear observation of signal transitions.

Complete testbench code for all modules is provided in Appendix A.

\subsubsection{Test Cases and Coverage}

Verification strategies adapt to module complexity. Small modules undergo exhaustive testing, while larger modules use statistical sampling.

\textbf{Full Adder:} Exhaustive testing covers all 8 input combinations using a simple increment pattern:
\begin{lstlisting}[style=verilog]
	repeat(7) begin
	#10; // Wait 10ns to observe outputs
	{A, B, cin} = {A, B, cin} + 3'b001; // Increment to next combination
	end
\end{lstlisting}
Waveform inspection confirms S and Cout values against the truth table in Figure~\ref{fig:full_adder_truth_table}.

\textbf{N-bit RCA:} Exhaustive testing requires $2^{2N}$ input combinations, making it feasible only for small N. Automatic verification compares against the native `+` operator:
\begin{lstlisting}[style=verilog]
	for (i = 0; i < (1 << N); i = i + 1) begin
	for (j = 0; j < (1 << N); j = j + 1) begin
	A = i;
	B = j;
	#5; // Propagation delay
	
	expected = {1'b0, A} + {1'b0, B} + cin_t;
	
	if ({cout_t, S} !== expected) begin
	$display("MISMATCH: Time=%0t, A=%0d, B=%0d, cin=%b", $time, A, B, cin_t);
	$display("       Expected: 0x%h (%0d)", expected, expected);
	$display("   Got:      0x%h (%0d)", {cout_t, S}, {cout_t, S});
	error_count = error_count + 1;
	end
	end
	end
\end{lstlisting}

\textbf{4-bit CLA:} Testing all 256 input combinations requires deriving the carry-out from group signals, since the module outputs Pg and Gg instead of a direct carry-out:
\begin{lstlisting}[style=verilog]
	// Temporary carry-out calculation for verification
	wire calculated_carry_out;
	assign calculated_carry_out = Gg | (Pg & carry_in);
\end{lstlisting}
The verification then compares against the native `+` operator, with error counting and reporting.

\textbf{64-bit CLA:} Exhaustive testing being non-viable ($2^{128}$ combinations), verification uses 50 random test cases:
\begin{lstlisting}[style=verilog]
	A = {$urandom, $urandom};
	B = {$urandom, $urandom};
	cin_t = $urandom % 2;  // Random carry input (0 or 1)
	#1; // Propagation delay
\end{lstlisting}
An enhanced terminal interface provides color-coded feedback, including overflow detection:
\begin{lstlisting}[style=verilog]
	else if (cout_t != 0) begin
	$display("%s[%0d] OVERFLOW%s | A=%d | B=%d | cin=%d | S=%d",
	yellow, i + 1, reset, A, B, cin_t, S);
	end
\end{lstlisting}

	
\subsubsection{Waveform Analysis}

GTKWave provides comprehensive visibility into both internal module signals and I/O ports. For functional verification, signals A, B, $C_{in}$, S, and $C_{out}$ are of primary interest.

Decimal representation of A, B, and S facilitates quick verification of addition results. Figure~\ref{fig:WexNRCA} demonstrates an 8-bit RCA addition where A = 138 and B = 72 produce the expected sum S = 210, with $C_{out}$ = $C_{in}$ = 0, confirming correct operation.

Overflow conditions require careful interpretation. Figure~\ref{fig:WexNRCAOverflow} illustrates a case where A = 146 and B = 110 should sum to 256, but this value exceeds the 8-bit representation range. The sum output S = 0 might initially suggest an error. However, switching to binary representation (Figure~\ref{fig:WexNRCAOverflowBin}) reveals the complete picture: $C_{out}$ = 1 and S = 8'b00000000. The concatenated result $\{C_{out}, S\}$ = 9'b100000000$ = 256$ confirms proper overflow handling. (Figures \ref{fig:WexNRCA},\ref{fig:WexNRCAOverflow} and \ref{fig:WexNRCAOverflowBin})

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-2EjFA.png}
		\caption{8-bit RCA addition waveform (decimal representation)}
		\label{fig:WexNRCA}
	\end{minipage}
	
	\vspace{1cm} 
	
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-2EjFAoverflow.png}
		\caption{Overflow condition in decimal representation}
		\label{fig:WexNRCAOverflow}
	\end{minipage}
	
	\vspace{1cm}
	
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-2EjFAoverflowbin.png}
		\caption{Overflow condition in binary representation revealing carry-out}
		\label{fig:WexNRCAOverflowBin}
	\end{minipage}
\end{figure}

For the 64-bit CLA, waveform inspection becomes impractical due to the enormous value range (0 to $2^{64}-1$) in decimal and the visual clutter of 64-bit binary values. These limitations reinforce the necessity of automated verification methodologies described in Section 3.3.2. 
	
	\subsection{CMOS Circuit Design}
	\subsubsection{Logic Gate Schematics}
	
The CMOS gates derived in Section 2.5 were implemented in LTspice to validate functionality and characterize timing performance. Figure \ref{fig:BasicInverter} shows the fundamental inverter, while Figures \ref{fig:OR2} and \ref{fig:AND2} implement 2-input OR and AND gates using NOR/NAND gates with output inverters. Figure \ref{fig:XOR2} shows the 8-transistor XOR implementation, and Figure \ref{fig:NOR4} demonstrates the 4-input NOR gate for fan-in delay analysis.

Two full adder implementations were constructed: Figure \ref{fig:AdderG} uses discrete gates (42 transistors), while Figure \ref{fig:Adder28} implements the optimized 28-transistor version derived through algebraic optimization.

\begin{figure}
	\centering
	\centering
	\begin{minipage}[b]{0.45\textwidth}
		\includegraphics[width=\textwidth]{3-3inputpulses.png}
		\caption{Input pulse configuration for testing}
		\label{fig:Inputpulses}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.45\textwidth}
		\includegraphics[width=\textwidth]{3-3NOT.png}
		\caption{CMOS inverter implementation}
		\label{fig:BasicInverter}
	\end{minipage}
	
\end{figure}

\begin{figure}
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-3OR2.png}
		\caption{2-input OR gate using NOR and inverter}
		\label{fig:OR2}
	\end{minipage}
\end{figure}

\begin{figure}
	\begin{minipage}[b]{1\textwidth}
		\centering
		\includegraphics[width=\textwidth]{3-3AND2.png}
		\caption{ 2-input AND gate using NAND and inverter}
		\label{fig:AND2}
	\end{minipage}
\end{figure}

\begin{figure}
	\centering
	\begin{minipage}[b]{0.45\textwidth}
		\includegraphics[width=\textwidth]{3-3XOR2.png}
		\caption{12-transistor XOR gate implementation}
		\label{fig:XOR2}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.5\textwidth}
		\includegraphics[width=\textwidth]{3-3NOR4.png}
		\caption{4-input NOR gate for fan-in delay analysis}
		\label{fig:NAND4}
	\end{minipage}
\end{figure}

\begin{figure}
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-3FACMOSG.png}
		\caption{FA using CMOS gates (42 transistors)}
		\label{fig:AdderG}
	\end{minipage}
\end{figure}

\begin{figure}
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{3-3FACMOS28.png}
		\caption{Optimized 28-transistor FA implementation}
		\label{fig:Adder28}
	\end{minipage}
\end{figure}

\subsubsection{SPICE Netlist Generation}

All circuits were simulated using BSIM Level 1 models with technology parameters representative of a 0.18µm process. The transistor models capture essential characteristics including threshold voltages, transconductance, and parasitic capacitances:

\begin{verbatim}
	.model PMOS_L PMOS (LEVEL=1 VTO=-0.6 KP=40u CGSO=0.2n CGDO=0.8n W=2u L=0.18u)
	.model NMOS_L NMOS (LEVEL=1 VTO=0.6 KP=120u CGSO=0.2n CGDO=0.2n W=4u L=0.18u)
\end{verbatim}

The NMOS-to-PMOS width ratio of 2:1 compensates for mobility differences, providing balanced rise/fall times where topology permits. Gate and drain capacitances were included to accurately model dynamic behavior.

\subsubsection{Simulation Setup in LTspice}

Each gate was characterized under  loading conditions with $C_L = 50\ \text{fF}$ at the output. Input vectors A, B, C, and D (representing $C_{in}$ for adders) provided comprehensive Boolean coverage through carefully timed pulses (Figure \ref{fig:Inputpulses}) with $V_{DD} = 1.8\ \text{V}$, $t_{on} = 5\ \text{ns}$, and transition times of 10-50 ps.

Propagation delays were measured automatically using LTspice's \texttt{.meas} directives, capturing transitions at the $V_{DD}/2$ switching point. For example, the XOR gate measurement:

\begin{verbatim}
	.meas TRAN T_PLH_XOR2 TRIG V(D)=0.9 RISE=1 TARG V(Z2)=0.9 RISE=1
	.meas TRAN T_PHL_XOR2 TRIG V(D)=0.9 RISE=2 TARG V(Z2)=0.9 FALL=1  
	.meas tran tp_XOR2 param='(T_PLH_XOR2 + T_PHL_XOR2)/2'
\end{verbatim}

This automated approach eliminated cursor placement errors and ensured consistent, precise timing measurements across all gate configurations.
	
	\section{Results and Analysis}
	\subsection{Functional Verification}
	\subsubsection{Full Adder Operation}
	
	Waveform analysis in GTKWave confirms the Full Adder's functional correctness across all eight possible input combinations. As shown in Figure~\ref{fig:WFA}, input transitions (green) occur every 10ns, while outputs (yellow) respond according to the truth table defined in Figure~\ref{fig:full_adder_truth_table}.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{1\textwidth}
			\includegraphics[width=\textwidth]{4-1WFA.png}
			\caption{Full Adder waveform verification showing input combinations and corresponding outputs}
			\label{fig:WFA}
		\end{minipage}
	\end{figure}
	
	The waveform demonstrates exact correspondence between simulated behavior and the theoretical truth table used for the module's design. Each input combination produces the expected sum and carry outputs, validating the Full Adder's implementation. 
	\subsubsection{Ripple-Carry Adder Verification}
	
	The Ripple-Carry Adder verification used a parameter value of N=8, enabling testing of all 65,536 ($2^{2N}$) possible input combinations. Execution of the compiled .vvp testbench file automatically verified each case against Verilog's native addition operator.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{0.6\textwidth}
			\includegraphics[width=\textwidth]{4-2RCAterminal.png}
			\caption{Terminal output confirming successful verification of all 65,536 test cases}
			\label{fig:RCAterminal}
		\end{minipage}
	\end{figure}
	
	As shown in Figure~\ref{fig:RCAterminal}, the terminal reports "All tests passed!" with zero mismatches.
	
	Waveform analysis in GTKWave confirms proper operation, though it reveals an important characteristic of behavioral simulation: all 65,536 test cases execute with simultaneous output transitions. Figure~\ref{fig:rca_waveform} demonstrates that even worst-case carry propagation scenarios (such as A = 8'b00000001, B = 8'b11111111) show instantaneous $C_{out}$ result.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{1\textwidth}
			\includegraphics[width=\textwidth]{4-3WCENbitFA.png}
			\caption{RCA waveform showing simultaneous output transitions across all test cases due to zero-delay simulation}
			\label{fig:rca_waveform}
		\end{minipage}
	\end{figure}
	
	While this verification confirms arithmetic correctness, the theoretical $O(N)$ propagation delay characteristic of the RCA architecture is not observable in this simulation. Verilog's zero-delay model computes all results within the same simulation timestep, masking the sequential carry ripple that would occur in physical implementation. 
	
	The verification methodology provides complete functional validation, while timing performance is analytically derived from the theoretical gate-level analysis presented in Section 2.3.
	 
	
\subsubsection{64-bit CLA Comprehensive Testing}

The 64-bit Carry Lookahead Adder was tested using the random sampling methodology described in Section 3.3.2. A total of 50 test cases were executed, combining random 64-bit operands with random carry-in values.

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{4-464CLATerminal1.png}
		\caption{First 10 test cases executed for 64-bit CLA verification}
		\label{fig:Terminal64CLA1}
	\end{minipage}
	
	\vspace{1cm} 
	
	\begin{minipage}[b]{1\textwidth}
		\includegraphics[width=\textwidth]{4-564CLATerminal2.png}
		\caption{Final 10 test cases and verification summary confirming zero mismatches}
		\label{fig:Terminal64CLA2}
	\end{minipage}
\end{figure}

As shown in Figures~\ref{fig:Terminal64CLA1} and~\ref{fig:Terminal64CLA2}, the color-coded terminal interface provides visual feedback:Green entries indicate successful addition without overflow, yellow entries flag unsigned overflow conditions where $C_{out} = 1$, the absence of red entries confirms zero functional mismatches.


All 50 test cases passed verification, with 28 cases (56 \% of the sample) triggering overflow detection. In overflow conditions, the correct result is obtained by considering the concatenated value $\{C_{out}, S\}$, as demonstrated in the waveform analysis of Section 3.2.3.
	
	\subsection{Performance Analysis}
	\subsubsection{Theoretical Performance Comparison}
	
	Given the limitations of behavioral Verilog simulation for timing and power analysis, this evaluation focuses on theoretical performance metrics derived from gate-level analysis.
	
	\begin{table}[h]
		\centering
		\caption{Theoretical Performance Comparison of Adder Architectures}
		\label{tab:performance_comparison}
		\begin{tabular}{lccc}
			\hline
			\textbf{Architecture} & \textbf{Delay} & \textbf{Gate Count} & \textbf{Area-Delay Product} \\
			\hline
			Full Adder (1-bit) & 3 gate delays & 5 gates & 15 \\
			4-bit RCA & $3 \times 4 = 12$ gate delays & $4 \times 5 = 20$ gates & 240 \\
			4-bit CLA & 3 gate delays & 26 gates & 78 \\
			64-bit RCA & $3 \times 64 = 192$ gate delays & $64 \times 5 = 320$ gates & 61,440 \\
			64-bit CLA & $4 \times \log_4 64 = 12$ gate delays & $\approx$ 488 gates & 5856 \\
			\hline
		\end{tabular}
	\end{table}
	
	 Simulation cannot capture actual propagation delays, as Verilog computes results instantaneously. The theoretical analysis from Section 2.4.3 shows the CLA achieving 16× theoretical speed improvement over RCA for 64-bit operations.
	 
	 Table \ref{tab:performance_comparison} shows an idealized comparison of ripple-carry and carry look-ahead adders. Each logic gate (regardless of fan-in or type) is assumed to have equal delay and area. This abstraction highlights the architectural complexity: the ripple-carry adder grows linearly with word size O(N) while the CLA grows logarithmically O(log N). However, this comparison does not reflect physical realities,A 4-input AND or OR gate, for instance, is slower and larger than a 2-input one, and XOR gates are especially expensive in transistor count.
	 
	 Thus, while the CLA appears to have low theoretical delay, in practice its complex carry-generation logic and high fan-in gates make it slower and more area-consuming than this ideal model suggests.
	
	Despite these practical considerations, the theoretical analysis validates the CLA's architectural superiority for large operand sizes, particularly in applications where speed outweighs area constraints.
 	
	\subsection{CMOS Simulation Results}
	\subsubsection{Gate-Level Timing Characteristics}
	 While Verilog simulations typically assume uniform gate delays, physical CMOS implementations exhibit significant timing variations due to capacitive effects and transistor arrangements. Table \ref{tab:tp_gates} summarizes measured propagation delays for various gates.
	 
	 \begin{table}[H]
	 	\centering
	 	\begin{tabularx}{\textwidth}{|X|X|X|X|}
	 		\hline
	 		\textbf{Gate} & \textbf{$t_{PLH}$ (ps)} & \textbf{$t_{PHL}$ (ps)} & \textbf{$t_{p}$ (ps)} \\ \hline
	 		NOT & 175.4 & 40.6 & 108.0 \\ \hline
	 		AND & 185.0 & 97.6 & 141.3 \\ \hline
	 		NAND & 138.0 & 57.9 & 97.9 \\ \hline
	 		OR & 174.3 & 216.7 & 195.5 \\ \hline
	 		NOR4 & 750.1 & 30.7 & 390.4 \\ \hline
	 		NOR4 (Sized) & 207.3 & 30.7 & 119.0 \\ \hline
	 		XOR & 352.0 & 29.6 & 190.8 \\ \hline
	 		OR4 & 246.7 & 394.5 & 320.6 \\ \hline
	 		AND4 & 291.6 & 126.2 & 208.9 \\ \hline
	 	\end{tabularx}
	 	\caption{Propagation delay times measured for different logic gates}
	 	\label{tab:tp_gates}
	 \end{table}
	 
	 The RC model explains these timing asymmetries. For the inverter (Figure \ref{fig:rcmodel}), $R_P \approx 2.7\ \text{k}\Omega$ and $R_N \approx 0.56\ \text{k}\Omega$ result in $t_{PLH} > t_{PHL}$. Series configurations dramatically increase delays, as evidenced by NOR4's 750 ps rise time due to four series PMOS transistors.
	  Proper transistor sizing improves NOR4 performance by 3.6×, demonstrating the critical importance of device optimization.
	 
	 \begin{figure}[h]
	 	\centering
	 	\begin{minipage}[b]{0.7\textwidth}
	 		\includegraphics[width=\textwidth]{4-3rcmodel.png}
	 		\caption{RC model for inverter explaining timing asymmetries}
	 		\label{fig:rcmodel}
	 	\end{minipage}
	 \end{figure}
	 
	 
	 Complex gates like full adders exhibit path-dependent delays due to multiple parallel paths with different series depths. Table \ref{tab:tp_adders_28T} compares gate-level and optimized 28-T implementations.
	 
	 \begin{table}[H]
	 	\centering
	 	\begin{tabularx}{\textwidth}{|X|X|X|X|}
	 		\hline
	 		\textbf{Module} & \textbf{$t_{PLH}$ (ps)} & \textbf{$t_{PHL}$ (ps)} & \textbf{$t_{p}$ (ps)} \\ \hline
	 		\multicolumn{4}{|l|}{\textbf{Adder (full gates)}} \\ \hline
	 		S & 632.5 & 120.0 & 376.2 \\ \hline
	 		Cout & 413.7 & 301.8 & 357.8 \\ \hline
	 		\multicolumn{4}{|l|}{\textbf{Adder 28-T}} \\ \hline
	 		S (worst case) & 422.1 & 223.5 & 322.8 \\ \hline
	 		S (best case) & 338.6 & 203.7 & 271.1 \\ \hline
	 		Cout (worst case) & 351.5 & 238.3 & 294.9 \\ \hline
	 		Cout (best case) & 347.7 & 175.1 & 261.4 \\ \hline
	 	\end{tabularx}
	 	\caption{Propagation delays for adder modules showing path-dependent timing}
	 	\label{tab:tp_adders_28T}
	 \end{table}
	 
	 The 28-T optimization provides 20\% speed improvement and 30\% area reduction. More importantly, the significant path-dependent variations (83 ps for Sum, 4 ps for Cout) have crucial implications for adder architectures.
	 
With this information, more precise timing analysis for larger adder modules can be performed. For example, a 4-bit ripple-carry adder using our characterized gates has a critical-path delay of:
\[ t_{ripple} = 4 \times (t_{p,XOR} + t_{p,AND} + t_{p,OR}) = 4 \times (190.8 + 141.3 + 195.5) \approx 2.11\ \text{ns} \]

Using the optimized Adder-28T implementation:
\[ t_{ripple28T} = 4 \times t_{p,FA28T} = 4 \times 294.9 \approx 1.18\ \text{ns} \]

For a 4-bit Carry Lookahead Adder using discrete gates:
\[ t_{CLA} = t_{p,XOR} + t_{p,AND4} + t_{p,OR4} = 190.8 + 208.9 + 320.6 \approx 0.72\ \text{ns} \]


While the gate-level CLA shows a significant 300\% speed improvement over the gate-level ripple-carry, this advantage reduces to approximately 160\% when comparing against the transistor-optimized Adder-28T. However, this comparison is somewhat unfair, as the CLA equations could also be implemented directly at the CMOS level for additional performance gains.

\subsubsection{Parasitic Impact Analysis}
	 
	Parasitic effects manifest as glitches and timing variations that extend beyond simple RC models, revealing the complex dynamic behavior of CMOS circuits.
	
	AND gates exhibited significant 0.4V glitches during specific input transitions (C↑, D↓) due to timing mismatches in series NMOS chains, as shown in Figure \ref{fig:spikeAND}. The glitch occurred when the slow turn-off of one series NMOS created a temporary conduction path during input transitions. This was effectively eliminated by optimizing input slope timing, reducing D's fall time from 50 ps to 10 ps (Figure \ref{fig:spikeANDfixed}).
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{0.47\textwidth}
			\includegraphics[width=\textwidth]{4-4AND04spike.png}
			\caption{AND gate glitch due to series NMOS timing mismatch}
			\label{fig:spikeAND}
		\end{minipage}
		\hspace{0.1cm}
		\begin{minipage}[b]{0.47\textwidth}
			\includegraphics[width=\textwidth]{4-4AND04fixed.png}
			\caption{Glitch elimination through input slope optimization}
			\label{fig:spikeANDfixed}
		\end{minipage}
	\end{figure}
	
	XOR gates displayed similar but more complex glitching behavior. A negative spike (1.799V → 1.76V) occurred during (C↑, D↓) transitions, accompanied by a 0.08V positive spike during (C↓, D↓) transitions (Figure \ref{fig:spikeXOR}). Input slope optimization reduced the first glitch but amplified the second to 0.37V (Figure \ref{fig:spikeXORfix}), demonstrating the trade-offs in glitch mitigation strategies.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{0.47\textwidth}
			\includegraphics[width=\textwidth]{4-4XORspike.png}
			\caption{XOR gate glitches showing multiple parasitic effects}
			\label{fig:spikeXOR}
		\end{minipage}
		\hspace{0.1cm}
		\begin{minipage}[b]{0.47\textwidth}
			\includegraphics[width=\textwidth]{4-4XORfix.png}
			\caption{Trade-off in XOR glitch mitigation}
			\label{fig:spikeXORfix}
		\end{minipage}
	\end{figure}
	
	Complex gates exhibited significant path-dependent timing variations exceeding 80 ps depending on input patterns, as evidenced in the Adder-28T waveforms (Figure \ref{fig:FA28Twaves}). These variations arise from different conduction paths through series/parallel transistor networks having distinct RC characteristics.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}[b]{1\textwidth}
			\includegraphics[width=\textwidth]{4-4FA28Twaves.png}
			\caption{Path-dependent timing variations in Adder-28T}
			\label{fig:FA28Twaves}
		\end{minipage}
	\end{figure}
	
	These parasitic effects necessitate careful timing analysis, hazard detection, and input slope control in production designs to ensure signal integrity and reliable operation.
	
	 \subsubsection{Layout Considerations}

	 Simulations assume ideal wiring; real layouts introduce additional RC delays
	 
	 The characterized gate delays provide a foundation for place-and-route tools to optimize timing closure in full-chip implementations.
	
	\section{Conclusions and Future Work}
	\subsection{Conclusions}
	
	The experimental results reveal a substantial divergence between Verilog abstraction and CMOS physical implementation. While Verilog provides a simplified approach to logic design that accelerates the development of complex modules and enables efficient arithmetic and conceptual validation, the underlying CMOS reality presents physical behaviors that significantly impact circuit performance. The investigation uncovered timing asymmetries and non-instantaneous state transitions inherent to CMOS gates, where even identical fan-in/fan-out configurations exhibit  propagation delays that become  important in complex modules.
	
	Direct gate-level transistor implementation proves  inefficient compared to equation-driven optimization at the transistor level. The Adder-28T module demonstrates this principle, achieving approximately 30\% area reduction and 20\% delay improvement through Boolean optimization. LTspice simulations further revealed transient spikes and glitches during finite-slope input transitions, highlighting the necessity of careful input slope control in physical implementations. Transistor sizing emerged as a powerful optimization technique, where adjusted width-length ratios reduce  resistance in series and parallel paths, enhancing current flow and reducing critical timing delays.
	
	\subsection{Limitations}
	
	This study focused primarily on RCA and CLA architectures, leaving alternative designs such as Carry-Skip Adders, Linear Carry-Select Adders, and Square-Root Carry-Select Adders unexplored. The MOS transistor models employed incorporated minimal parameters for parasitic effects, prioritizing timing delay analysis over physical phenomenon characterization. This limited approach, while sufficient for initial timing investigations, necessarily omitted certain second-order effects that would become relevant in production-grade designs. The analysis also maintained simplified loading conditions that may not fully represent the complex interconnect parasitics encountered in actual integrated circuit layouts.
	
	\subsection{Future Improvements}
	
	The full adder architecture can be extended into an adder-subtractor module by implementing a control signal M connected to the global carry-in and XOR gates at each bit of the second operand input. When M equals 0, the second operand remains unchanged and the module functions as a conventional adder; when M equals 1, the second operand becomes complemented and the module operates as a subtractor. This modification necessitates rethinking overflow detection since the MSB transitions to representing signed magnitude rather than an additional numeric digit. Future work could also incorporate more physically accurate MOS transistor models, which would capture additional parasitic effects including detailed short-channel behaviors, quantum mechanical effects, and advanced leakage current mechanisms. Further investigation could explore power consumption analysis, temperature variation effects, and process corner simulations to develop a more comprehensive understanding of real-world CMOS implementation challenges.
	
	\section{References}
	
	\begin{thebibliography}{9}
		\bibitem{sedra2019}
		A. Sedra, K. Smith, 
		\textit{Microelectronic Circuits}, 
		8th ed., Oxford University Press, 2019.
		
		\bibitem{mano2018}
		M. Morris Mano, M. D. Ciletti,
		\textit{Digital Design}, 
		6th ed., Pearson, 2018.
		
		\bibitem{vidhyadharan2020}
		S. Vidhyadharan,
		\textit{VLSI Design Notes},
		Lecture Notes
	\end{thebibliography}
	
	\section*{Software Tools}
	\begin{itemize}
		\item \textbf{Digital by hneemann}: Logic design and simulation
		\item \textbf{Draw.io}: System schematics and diagrams
		\item \textbf{TEXstudio}: Document preparation
		\item \textbf{Icarus Verilog + GTKWave}: Verilog simulation
		\item \textbf{LTspice}: CMOS circuit analysis
	\end{itemize}
	\newpage
\section*{Appendix A: Full Testbenches codes}
	
	\begin{lstlisting}[style=verilog, caption={Single-bit Full Adder testbench}, label=code:full_adderTB ]
	
	/**
	* Testbench for the full_adder module.
	* 
	* Verifies by testing all 8 possible input combinations (2^3).
	* Output waveforms can be viewed in GTKWave for visual inspection.
	*
	*/
	`timescale 1ns/1ps
	
	module full_adder_tb();
	
	reg  A, B, cin;  // Inputs to the Device Under Test (DUT)
	wire S, cout;     // Outputs from the DUT
	
	// Instantiate the DUT
	full_adder DUT (
	.x(A),
	.y(B), 
	.z(cin),
	.s(S),
	.c(cout)
	);
	
	initial begin
	// Initialize simulation and create waveform file
	$dumpfile("full_adder.vcd");
	$dumpvars(0, full_adder_tb);
	
	// Start with all inputs at 0
	{A, B, cin} = 3'b000;
	
	// Test all 8 input combinations (0 to 7)
	repeat(7) begin
	#10; // Wait for 10ns to observe outputs
	{A, B, cin} = {A, B, cin} + 3'b001; // Increment to next combination
	end
	
	#10 $finish;
	end
	
	endmodule
	
	\end{lstlisting}
	
	\begin{lstlisting}[style=verilog, caption={N-bit Ripple Carry Adder testbench}, label=code:N-bitRCATB]
	
	/**
	* Testbench for the N-bit Ripple Carry Adder (RCA)
	* 
	* Verifies the RCA functionality by testing all possible input 
	* combinations for a given bit width N. Includes automatic result checking.
	* 
	* Tests all 2^(2N) input combinations for operands A and B
	* Compares RCA results against Verilog's native + operator
	* 
	* @note For large N (>8), simulation time grows exponentially. Use small N for quick verification.
	* 
	* Output waveforms can be viewed in GTKWave for visual inspection.
	*/
	
	`timescale 1ns/1ps
	
	module ripple_adder_tb #(parameter N = 8) ();
	
	reg  [N-1:0] A, B;        // Input operands to DUT
	reg          cin_t;       
	wire [N-1:0] S;           // Sum output from DUT
	wire         cout_t;      
	
	// Verification signals
	reg  [N:0]   expected;    // Reference result using Verilog's native + operator
	integer      error_count; // Tracks verification errors
	integer i, j;
	
	// Device Under Test instantiation
	ripple_carry_adder #(.N(N)) DUT (
	.N1(A),
	.N2(B), 
	.cin(cin_t),
	.St(S),
	.cout(cout_t)
	);
	
	initial begin
	// Initialize simulation
	$dumpfile("ripple_adder.vcd");
	$dumpvars(0, ripple_adder_tb);
	
	error_count = 0;
	cin_t = 1'b0;  // Start with carry-in = 0
	
	for (i = 0; i < (1 << N); i = i + 1) begin
	for (j = 0; j < (1 << N); j = j + 1) begin
	A = i;
	B = j;
	#5; // Wait for propagation
	
	// Calculate expected result using + operator
	expected = A + B + cin_t;
	
	// Compare DUT output with expected result
	if ({cout_t, S} !== expected) begin
	$display("MISMATCH: Time=%0t, A=%0d, B=%0d, cin=%b", $time, A, B, cin_t);
	$display("       Expected: 0x%h (%0d)", expected, expected);
	$display("       Got:      0x%h (%0d)", {cout_t, S}, {cout_t, S});
	error_count = error_count + 1;
	
	end
	end
	end
	
	if (error_count == 0) begin
	$display("All tests passed!");
	end 
	else begin
	$display(" %0d mismatches detected", error_count);
	end
	
	#10 $finish;
	end
	
	endmodule
	\end{lstlisting}
	
	\begin{lstlisting}[style=verilog, caption={4-bit Carry Lookahead Adder testbech}, label=code:4bitCLATB]
		
	/* 
	* Testbech for 4-bits Carry lookahead adder.
	* Verifies all posible combinations for 4 bits operators A and B. 
	* Includes automatic result checking.
	* Compares CLA results against Verilog's native + operator
	* 
	* Output waveforms can be viewed in GTKWave for visual inspection.
	*/
	
	
	`timescale 1ns/1ps
	
	module carry_lookahead_4bit_tb # (parameter N = 4) ();
	reg [N-1:0] A, B;  // Input operands to test
	reg         carry_in;              // Carry-in signal  
	wire [N-1:0] sum_out;              // Sum output from CLA
	reg [N:0]    expected;      // Expected result for verification
	wire         group_generate, group_propagate;  // Group signals
	integer i-out calculation for verification
	wire calculated_carry_out;
	assign calculated_carry_out = group_generate | (group_propagate & carry_in);
	
	carry_lookahead_4bit DUT (
	.A(A), 
	.B(B), 
	.cin(carry_in), , j, error_count;         // Loop counters and error tracker
	
	// Temporary carry
	.S(sum_out), 
	.Gg(group_generate), 
	.Pg(group_propagate)
	);
	
	initial 
	begin
	error_count = 0;    // Initialize error counter
	carry_in = 0;       // Start with carry-in = 0
	$dumpfile("carry_lookahead_4bit.vcd");
	$dumpvars(0, carry_lookahead_4bit_tb);
	
	
	for(j = 0; j < (1 << N); j = j + 1) begin 
	for(i = 0; i < (1 << N); i = i + 1) begin
	A = i; 
	B = j; 
	#5;  
	
	// Calculate expected result using Verilog addition
	expected= A + B + carry_in;
	
	// Compare CLA output with expected result
	if ({calculated_carry_out, sum_out} !== expected) begin
	$display("Error: A=%d, B=%d, Expected=0x%h, Got=0x%h", 
	A, B, expected, {calculated_carry_out, sum_out});
	error_count = error_count + 1;
	end
	end
	end
	
	// Test result summary
	if (error_count == 0)
	$display("All tests passed");
	else
	$display("mismatches found", error_count);
	
	#10 $finish;
	end
	
	endmodule
	
	\end{lstlisting}
	
	\begin{lstlisting}[style=verilog, caption={64-bit Full Carry Lookahead Adder testbench}, label=code:64bitCLATB ]
	`timescale 1ns/1ps
	
	/*
	* Testbench for 64-bit Carry Lookahead Adder (CLA)
	* 
	* Tests the CLA implementation by comparing against Verilog's native addition.
	* Since testing of all 2^128 combinations is impossible, this testbench
	* uses 50 random input combinations to verify functionality.
	* 
	* 
	* - Color-coded terminal output for easy result interpretation
	* - Overflow detection and reporting
	* - Mismatch detection between CLA and native addition
	*
	* Output waveforms can be viewed in GTKWave for visual inspection.
	*
	* NOTE: Input operands are treated as unsigned for proper overflow detection.
	*/
	
	module add64bitsCLA_tb #(parameter N = 64) ();
	
	// Testbench signals
	reg [N-1:0] A, B;
	reg cin_t;
	wire [N-1:0] S;
	reg [N:0] expected;  // N+1 bits to accommodate carry out
	wire cout_t;
	integer i, errors = 0;
	
	
	add64CLA DUT (.A(A), .B(B), .carry_in(cin_t), .S(S), .carry_out(cout_t));
	
	
	string green  = "\033[32m";
	string red    = "\033[31m";
	string yellow = "\033[33m";
	string reset  = "\033[0m";
	
	initial begin
	// Initialize inputs
	cin_t = 0;
	A = 0;
	B = 0;
	
	$dumpfile("add64bitsCLA.vcd");
	$dumpvars(0, add64bitsCLA_tb);
	
	$display("====== Testbench Start ==========");
	
	// Test 50 random number combinations + random input carry
	for (i = 0; i < 50; i = i + 1) begin
	
	A = {$urandom, $urandom};
	B = {$urandom, $urandom};
	cin_t = $urandom % 2;  // Random carry input (0 or 1)
	#1;  
	
	
	// Use N+1 bits to properly handle carry out
	expected = {1'b0, A} + {1'b0, B} + cin_t;
	
	
	if ({cout_t, S} !== expected) begin
	$display("%s[%0d] MISMATCH%s | A=%d | B=%d | Exp=%d | Got=%d",
	red, i + 1, reset, A, B, expected, {cout_t, S});
	errors = errors + 1;
	end 
	// Check for overflow 
	else if (cout_t != 0) begin
	$display("%s[%0d] OVERFLOW%s | A=%d | B=%d | cin=%d | S=%d",
	yellow, i + 1, reset, A, B, cin_t, S);
	end
	
	else begin
	$display("%s[%0d]     OK%s   | A=%d | B=%d | cin=%d | S=%d",
	green, i + 1, reset, A, B, cin_t, S);
	end
	end
	
	
	if (errors == 0)
	$display("%sNo mismatches detected%s", green, reset);
	else
	$display("%s%d mismatches detected%s", red, errors, reset);
	
	$display("===== Testbench Complete ====");
	
	
	#10 $finish;
	end
	
	endmodule	
		
		
	\end{lstlisting}
	

	
	
\end{document}